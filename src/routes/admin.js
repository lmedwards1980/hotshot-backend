// Generated by ScriptBuilder - 324 – Admin Routes
// Feature: core | Role: core

// =========================================================
// 324 – Admin Routes
// Feature: admin
// Role: routes
// Group: Backend API
// =========================================================
// FILE: src/routes/admin.js
// =========================================================

const express = require('express');
const router = express.Router();
const { pool } = require('../db/pool');
const { authenticate, requireAdmin } = require('../middleware/auth');
const verificationService = require('../services/verificationService');
const documentService = require('../services/documentService');

// All routes require admin
router.use(authenticate, requireAdmin);

// ═══════════════════════════════════════════════════════════════════════════════
// Dashboard Stats
// ═══════════════════════════════════════════════════════════════════════════════

router.get('/dashboard', async (req, res) => {
  try {
    // Get counts
    const stats = await pool.query(`
      SELECT
        (SELECT COUNT(*) FROM users WHERE user_type = 'shipper') as total_shippers,
        (SELECT COUNT(*) FROM users WHERE user_type = 'driver') as total_drivers,
        (SELECT COUNT(*) FROM driver_profiles WHERE verification_status = 'verified') as verified_drivers,
        (SELECT COUNT(*) FROM driver_profiles WHERE verification_status = 'pending') as pending_drivers,
        (SELECT COUNT(*) FROM loads WHERE status = 'posted') as active_loads,
        (SELECT COUNT(*) FROM loads WHERE status = 'delivered' AND delivered_at > NOW() - INTERVAL '24 hours') as delivered_today,
        (SELECT COUNT(*) FROM disputes WHERE status = 'open') as open_disputes,
        (SELECT COALESCE(SUM(total_price_cents), 0) FROM loads WHERE delivered_at > NOW() - INTERVAL '30 days') as revenue_30d
    `);
    
    res.json(stats.rows[0]);
  } catch (error) {
    console.error('[Admin] Dashboard error:', error);
    res.status(500).json({ error: 'Failed to get dashboard stats' });
  }
});

// ═══════════════════════════════════════════════════════════════════════════════
// User Management
// ═══════════════════════════════════════════════════════════════════════════════

router.get('/users', async (req, res) => {
  try {
    const { type, status, search, page = 1, limit = 20 } = req.query;
    const offset = (page - 1) * limit;
    
    let query = `
      SELECT u.*, 
             dp.verification_status,
             (SELECT COUNT(*) FROM loads WHERE shipper_id = u.id OR driver_id = u.id) as load_count
      FROM users u
      LEFT JOIN driver_profiles dp ON u.id = dp.user_id
      WHERE 1=1
    `;
    const params = [];
    let paramIndex = 1;
    
    if (type) {
      query += ` AND u.user_type = $${paramIndex++}`;
      params.push(type);
    }
    
    if (status === 'verified') {
      query += ` AND dp.verification_status = 'verified'`;
    } else if (status === 'pending') {
      query += ` AND dp.verification_status IN ('pending', 'documents_submitted')`;
    }
    
    if (search) {
      query += ` AND (u.name ILIKE $${paramIndex} OR u.email ILIKE $${paramIndex} OR u.phone ILIKE $${paramIndex})`;
      params.push(`%${search}%`);
      paramIndex++;
    }
    
    query += ` ORDER BY u.created_at DESC LIMIT $${paramIndex++} OFFSET $${paramIndex++}`;
    params.push(limit, offset);
    
    const result = await pool.query(query, params);
    
    // Get total count
    const countResult = await pool.query(
      `SELECT COUNT(*) FROM users u LEFT JOIN driver_profiles dp ON u.id = dp.user_id WHERE 1=1`
    );
    
    res.json({
      users: result.rows.map(u => ({
        id: u.id,
        name: u.name,
        email: u.email,
        phone: u.phone,
        userType: u.user_type,
        rating: u.rating,
        isVerified: u.is_verified,
        verificationStatus: u.verification_status,
        loadCount: u.load_count,
        createdAt: u.created_at,
      })),
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: parseInt(countResult.rows[0].count),
      },
    });
  } catch (error) {
    console.error('[Admin] Users list error:', error);
    res.status(500).json({ error: 'Failed to get users' });
  }
});

router.get('/users/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.query(`
      SELECT u.*, dp.*
      FROM users u
      LEFT JOIN driver_profiles dp ON u.id = dp.user_id
      WHERE u.id = $1
    `, [id]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    const user = result.rows[0];
    
    // Get documents if driver
    let documents = null;
    if (user.user_type === 'driver') {
      documents = await documentService.getDriverDocumentStatus(pool, id);
    }
    
    // Get recent loads
    const loadsResult = await pool.query(`
      SELECT id, pickup_city, delivery_city, status, total_price_cents, created_at
      FROM loads 
      WHERE shipper_id = $1 OR driver_id = $1
      ORDER BY created_at DESC LIMIT 10
    `, [id]);
    
    res.json({
      user: {
        id: user.id,
        name: user.name,
        email: user.email,
        phone: user.phone,
        userType: user.user_type,
        rating: user.rating,
        ratingCount: user.rating_count,
        isActive: user.is_active,
        createdAt: user.created_at,
      },
      driverProfile: user.user_type === 'driver' ? {
        cdlNumber: user.cdl_number,
        cdlState: user.cdl_state,
        cdlExpiry: user.cdl_expiry,
        mcNumber: user.mc_number,
        dotNumber: user.dot_number,
        truckType: user.truck_type,
        maxWeight: user.max_weight_lbs,
        verificationStatus: user.verification_status,
        verifiedAt: user.verified_at,
      } : null,
      documents,
      recentLoads: loadsResult.rows,
    });
  } catch (error) {
    console.error('[Admin] User detail error:', error);
    res.status(500).json({ error: 'Failed to get user' });
  }
});

router.patch('/users/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { isActive, isVerified } = req.body;
    
    const updates = [];
    const params = [id];
    let paramIndex = 2;
    
    if (typeof isActive === 'boolean') {
      updates.push(`is_active = $${paramIndex++}`);
      params.push(isActive);
    }
    
    if (typeof isVerified === 'boolean') {
      updates.push(`is_verified = $${paramIndex++}`);
      params.push(isVerified);
    }
    
    if (updates.length === 0) {
      return res.status(400).json({ error: 'No updates provided' });
    }
    
    await pool.query(
      `UPDATE users SET ${updates.join(', ')}, updated_at = NOW() WHERE id = $1`,
      params
    );
    
    res.json({ message: 'User updated' });
  } catch (error) {
    console.error('[Admin] User update error:', error);
    res.status(500).json({ error: 'Failed to update user' });
  }
});

// ═══════════════════════════════════════════════════════════════════════════════
// Driver Verification
// ═══════════════════════════════════════════════════════════════════════════════

router.get('/verification/pending', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT u.id, u.name, u.email, u.phone, u.created_at,
             dp.verification_status, dp.cdl_number, dp.cdl_state, dp.truck_type
      FROM users u
      JOIN driver_profiles dp ON u.id = dp.user_id
      WHERE dp.verification_status IN ('pending', 'documents_submitted', 'background_check_pending')
      ORDER BY u.created_at ASC
    `);
    
    const drivers = [];
    for (const row of result.rows) {
      const docStatus = await documentService.getDriverDocumentStatus(pool, row.id);
      drivers.push({
        id: row.id,
        name: row.name,
        email: row.email,
        phone: row.phone,
        verificationStatus: row.verification_status,
        cdlNumber: row.cdl_number,
        cdlState: row.cdl_state,
        truckType: row.truck_type,
        documentsComplete: docStatus.complete,
        documentsProgress: docStatus.progress,
        createdAt: row.created_at,
      });
    }
    
    res.json({ drivers });
  } catch (error) {
    console.error('[Admin] Pending verification error:', error);
    res.status(500).json({ error: 'Failed to get pending drivers' });
  }
});

router.post('/verification/:driverId/approve', async (req, res) => {
  try {
    const { driverId } = req.params;
    const { notes } = req.body;
    
    await verificationService.manualVerify(driverId, req.user.id, notes || '');
    res.json({ message: 'Driver approved' });
  } catch (error) {
    console.error('[Admin] Approve error:', error);
    res.status(500).json({ error: 'Failed to approve driver' });
  }
});

router.post('/verification/:driverId/reject', async (req, res) => {
  try {
    const { driverId } = req.params;
    const { reason } = req.body;
    
    if (!reason) {
      return res.status(400).json({ error: 'Rejection reason required' });
    }
    
    await verificationService.manualReject(driverId, req.user.id, reason);
    res.json({ message: 'Driver rejected' });
  } catch (error) {
    console.error('[Admin] Reject error:', error);
    res.status(500).json({ error: 'Failed to reject driver' });
  }
});

router.get('/verification/:driverId/documents/:docType', async (req, res) => {
  try {
    const { driverId, docType } = req.params;
    
    const result = await pool.query(
      `SELECT s3_key FROM driver_documents WHERE driver_id = $1 AND document_type = $2`,
      [driverId, docType]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Document not found' });
    }
    
    const viewUrl = await documentService.getViewUrl(result.rows[0].s3_key);
    res.json({ url: viewUrl });
  } catch (error) {
    console.error('[Admin] View document error:', error);
    res.status(500).json({ error: 'Failed to get document' });
  }
});

// ═══════════════════════════════════════════════════════════════════════════════
// Load Management
// ═══════════════════════════════════════════════════════════════════════════════

router.get('/loads', async (req, res) => {
  try {
    const { status, page = 1, limit = 20 } = req.query;
    const offset = (page - 1) * limit;
    
    let query = `
      SELECT l.*, 
             s.name as shipper_name,
             d.name as driver_name
      FROM loads l
      JOIN users s ON l.shipper_id = s.id
      LEFT JOIN users d ON l.driver_id = d.id
      WHERE 1=1
    `;
    const params = [];
    let paramIndex = 1;
    
    if (status) {
      query += ` AND l.status = $${paramIndex++}`;
      params.push(status);
    }
    
    query += ` ORDER BY l.created_at DESC LIMIT $${paramIndex++} OFFSET $${paramIndex++}`;
    params.push(limit, offset);
    
    const result = await pool.query(query, params);
    
    res.json({
      loads: result.rows.map(l => ({
        id: l.id,
        pickupCity: l.pickup_city,
        pickupState: l.pickup_state,
        deliveryCity: l.delivery_city,
        deliveryState: l.delivery_state,
        status: l.status,
        totalPrice: l.total_price_cents,
        shipperName: l.shipper_name,
        driverName: l.driver_name,
        createdAt: l.created_at,
      })),
    });
  } catch (error) {
    console.error('[Admin] Loads error:', error);
    res.status(500).json({ error: 'Failed to get loads' });
  }
});

// ═══════════════════════════════════════════════════════════════════════════════
// Disputes Management
// ═══════════════════════════════════════════════════════════════════════════════

router.get('/disputes', async (req, res) => {
  try {
    const { status = 'open' } = req.query;
    
    const result = await pool.query(`
      SELECT d.*, 
             l.pickup_city, l.delivery_city, l.total_price_cents,
             fb.name as filed_by_name,
             fa.name as filed_against_name
      FROM disputes d
      JOIN loads l ON d.load_id = l.id
      JOIN users fb ON d.filed_by = fb.id
      LEFT JOIN users fa ON d.filed_against = fa.id
      WHERE d.status = $1
      ORDER BY d.created_at ASC
    `, [status]);
    
    res.json({ disputes: result.rows });
  } catch (error) {
    console.error('[Admin] Disputes error:', error);
    res.status(500).json({ error: 'Failed to get disputes' });
  }
});

// ═══════════════════════════════════════════════════════════════════════════════
// Payments & Revenue
// ═══════════════════════════════════════════════════════════════════════════════

router.get('/revenue', async (req, res) => {
  try {
    const { period = '30' } = req.query;
    
    const result = await pool.query(`
      SELECT 
        DATE_TRUNC('day', delivered_at) as date,
        COUNT(*) as loads_delivered,
        SUM(total_price_cents) as total_revenue,
        SUM(platform_fee_cents) as platform_fees,
        SUM(driver_payout_cents) as driver_payouts
      FROM loads
      WHERE status = 'delivered' 
        AND delivered_at > NOW() - INTERVAL '${parseInt(period)} days'
      GROUP BY DATE_TRUNC('day', delivered_at)
      ORDER BY date ASC
    `);
    
    res.json({ revenue: result.rows });
  } catch (error) {
    console.error('[Admin] Revenue error:', error);
    res.status(500).json({ error: 'Failed to get revenue' });
  }
});

module.exports = router;
