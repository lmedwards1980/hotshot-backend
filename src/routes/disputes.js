// Generated by ScriptBuilder - 323 – Dispute Routes
// Feature: core | Role: core

// =========================================================
// 323 – Dispute Routes
// Feature: disputes
// Role: routes
// Group: Backend API
// =========================================================
// FILE: src/routes/disputes.js
// =========================================================

const express = require('express');
const router = express.Router();
const { pool } = require('../db/pool');
const { authenticate, requireAdmin } = require('../middleware/auth');
const emailService = require('../services/emailService');

const DISPUTE_REASONS = {
  DAMAGED_FREIGHT: 'damaged_freight',
  MISSING_ITEMS: 'missing_items',
  LATE_DELIVERY: 'late_delivery',
  NO_SHOW_DRIVER: 'no_show_driver',
  NO_SHOW_SHIPPER: 'no_show_shipper',
  WRONG_DELIVERY: 'wrong_delivery',
  PAYMENT_ISSUE: 'payment_issue',
  UNPROFESSIONAL: 'unprofessional',
  OTHER: 'other',
};

const DISPUTE_STATUS = {
  OPEN: 'open',
  UNDER_REVIEW: 'under_review',
  AWAITING_RESPONSE: 'awaiting_response',
  RESOLVED: 'resolved',
  CLOSED: 'closed',
};

const RESOLUTIONS = {
  FULL_REFUND: 'full_refund',
  PARTIAL_REFUND: 'partial_refund',
  NO_REFUND: 'no_refund',
  DRIVER_PAID: 'driver_paid',
  SPLIT_DECISION: 'split_decision',
  DISMISSED: 'dismissed',
};

// Open a dispute
router.post('/', authenticate, async (req, res) => {
  try {
    const { loadId, reason, description, evidence } = req.body;
    
    if (!loadId || !reason || !description) {
      return res.status(400).json({ error: 'Missing required fields' });
    }
    
    if (!Object.values(DISPUTE_REASONS).includes(reason)) {
      return res.status(400).json({ error: 'Invalid dispute reason' });
    }
    
    // Get load and verify user is involved
    const loadResult = await pool.query(
      `SELECT l.*, 
              s.name as shipper_name, s.email as shipper_email,
              d.name as driver_name, d.email as driver_email
       FROM loads l
       JOIN users s ON l.shipper_id = s.id
       LEFT JOIN users d ON l.driver_id = d.id
       WHERE l.id = $1 AND (l.shipper_id = $2 OR l.driver_id = $2)`,
      [loadId, req.user.id]
    );
    
    if (loadResult.rows.length === 0) {
      return res.status(404).json({ error: 'Load not found or not authorized' });
    }
    
    const load = loadResult.rows[0];
    
    // Check if dispute already exists
    const existingDispute = await pool.query(
      `SELECT id FROM disputes WHERE load_id = $1 AND status NOT IN ('resolved', 'closed')`,
      [loadId]
    );
    
    if (existingDispute.rows.length > 0) {
      return res.status(400).json({ error: 'Active dispute already exists for this load' });
    }
    
    // Determine who is being disputed
    const isShipper = load.shipper_id === req.user.id;
    const filedBy = req.user.id;
    const filedAgainst = isShipper ? load.driver_id : load.shipper_id;
    
    // Create dispute
    const disputeResult = await pool.query(`
      INSERT INTO disputes (
        load_id, filed_by, filed_against, reason, description, 
        evidence_urls, status, created_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
      RETURNING *
    `, [
      loadId, filedBy, filedAgainst, reason, description,
      JSON.stringify(evidence || []), DISPUTE_STATUS.OPEN
    ]);
    
    const dispute = disputeResult.rows[0];
    
    // Update load status
    await pool.query(
      `UPDATE loads SET status = 'disputed', updated_at = NOW() WHERE id = $1`,
      [loadId]
    );
    
    // Notify the other party
    const otherPartyEmail = isShipper ? load.driver_email : load.shipper_email;
    const otherPartyName = isShipper ? load.driver_name : load.shipper_name;
    
    if (otherPartyEmail) {
      await emailService.sendDisputeOpened(
        otherPartyEmail,
        otherPartyName,
        loadId,
        reason
      );
    }
    
    res.status(201).json({
      message: 'Dispute opened successfully',
      dispute: {
        id: dispute.id,
        loadId: dispute.load_id,
        reason: dispute.reason,
        status: dispute.status,
        createdAt: dispute.created_at,
      },
    });
  } catch (error) {
    console.error('[Disputes] Open error:', error);
    res.status(500).json({ error: 'Failed to open dispute' });
  }
});

// Get user's disputes
router.get('/', authenticate, async (req, res) => {
  try {
    const { status } = req.query;
    
    let query = `
      SELECT d.*, 
             l.pickup_city, l.delivery_city, l.total_price_cents,
             fb.name as filed_by_name,
             fa.name as filed_against_name
      FROM disputes d
      JOIN loads l ON d.load_id = l.id
      JOIN users fb ON d.filed_by = fb.id
      LEFT JOIN users fa ON d.filed_against = fa.id
      WHERE (d.filed_by = $1 OR d.filed_against = $1)
    `;
    
    const params = [req.user.id];
    
    if (status) {
      query += ` AND d.status = $2`;
      params.push(status);
    }
    
    query += ` ORDER BY d.created_at DESC`;
    
    const result = await pool.query(query, params);
    
    res.json({
      disputes: result.rows.map(d => ({
        id: d.id,
        loadId: d.load_id,
        pickupCity: d.pickup_city,
        deliveryCity: d.delivery_city,
        amount: d.total_price_cents,
        reason: d.reason,
        status: d.status,
        filedByName: d.filed_by_name,
        filedAgainstName: d.filed_against_name,
        isFiledByMe: d.filed_by === req.user.id,
        createdAt: d.created_at,
        resolvedAt: d.resolved_at,
      })),
    });
  } catch (error) {
    console.error('[Disputes] List error:', error);
    res.status(500).json({ error: 'Failed to get disputes' });
  }
});

// Get dispute details
router.get('/:id', authenticate, async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.query(`
      SELECT d.*, 
             l.pickup_city, l.pickup_state, l.delivery_city, l.delivery_state,
             l.total_price_cents, l.driver_payout_cents,
             fb.name as filed_by_name, fb.email as filed_by_email,
             fa.name as filed_against_name, fa.email as filed_against_email
      FROM disputes d
      JOIN loads l ON d.load_id = l.id
      JOIN users fb ON d.filed_by = fb.id
      LEFT JOIN users fa ON d.filed_against = fa.id
      WHERE d.id = $1 AND (d.filed_by = $2 OR d.filed_against = $2)
    `, [id, req.user.id]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Dispute not found' });
    }
    
    const dispute = result.rows[0];
    
    // Get messages
    const messagesResult = await pool.query(`
      SELECT dm.*, u.name as sender_name, u.user_type as sender_type
      FROM dispute_messages dm
      JOIN users u ON dm.sender_id = u.id
      WHERE dm.dispute_id = $1
      ORDER BY dm.created_at ASC
    `, [id]);
    
    res.json({
      dispute: {
        id: dispute.id,
        loadId: dispute.load_id,
        reason: dispute.reason,
        description: dispute.description,
        status: dispute.status,
        resolution: dispute.resolution,
        resolutionNotes: dispute.resolution_notes,
        evidenceUrls: dispute.evidence_urls,
        load: {
          pickupCity: dispute.pickup_city,
          pickupState: dispute.pickup_state,
          deliveryCity: dispute.delivery_city,
          deliveryState: dispute.delivery_state,
          totalPrice: dispute.total_price_cents,
          driverPayout: dispute.driver_payout_cents,
        },
        filedBy: {
          name: dispute.filed_by_name,
          isMe: dispute.filed_by === req.user.id,
        },
        filedAgainst: {
          name: dispute.filed_against_name,
          isMe: dispute.filed_against === req.user.id,
        },
        createdAt: dispute.created_at,
        resolvedAt: dispute.resolved_at,
      },
      messages: messagesResult.rows.map(m => ({
        id: m.id,
        message: m.message,
        senderName: m.sender_name,
        senderType: m.sender_type,
        isMe: m.sender_id === req.user.id,
        createdAt: m.created_at,
      })),
    });
  } catch (error) {
    console.error('[Disputes] Get error:', error);
    res.status(500).json({ error: 'Failed to get dispute' });
  }
});

// Add message to dispute
router.post('/:id/messages', authenticate, async (req, res) => {
  try {
    const { id } = req.params;
    const { message } = req.body;
    
    if (!message?.trim()) {
      return res.status(400).json({ error: 'Message required' });
    }
    
    // Verify user is involved in dispute
    const disputeResult = await pool.query(
      `SELECT id FROM disputes WHERE id = $1 AND (filed_by = $2 OR filed_against = $2)`,
      [id, req.user.id]
    );
    
    if (disputeResult.rows.length === 0) {
      return res.status(404).json({ error: 'Dispute not found' });
    }
    
    const result = await pool.query(`
      INSERT INTO dispute_messages (dispute_id, sender_id, message, created_at)
      VALUES ($1, $2, $3, NOW())
      RETURNING *
    `, [id, req.user.id, message.trim()]);
    
    res.status(201).json({
      message: {
        id: result.rows[0].id,
        message: result.rows[0].message,
        createdAt: result.rows[0].created_at,
      },
    });
  } catch (error) {
    console.error('[Disputes] Add message error:', error);
    res.status(500).json({ error: 'Failed to add message' });
  }
});

// ═══════════════════════════════════════════════════════════════════════════════
// Admin endpoints
// ═══════════════════════════════════════════════════════════════════════════════

// Resolve dispute (admin only)
router.post('/:id/resolve', authenticate, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { resolution, notes, refundAmount } = req.body;
    
    if (!resolution || !Object.values(RESOLUTIONS).includes(resolution)) {
      return res.status(400).json({ error: 'Invalid resolution' });
    }
    
    // Get dispute with parties
    const disputeResult = await pool.query(`
      SELECT d.*, 
             fb.name as filed_by_name, fb.email as filed_by_email,
             fa.name as filed_against_name, fa.email as filed_against_email
      FROM disputes d
      JOIN users fb ON d.filed_by = fb.id
      LEFT JOIN users fa ON d.filed_against = fa.id
      WHERE d.id = $1
    `, [id]);
    
    if (disputeResult.rows.length === 0) {
      return res.status(404).json({ error: 'Dispute not found' });
    }
    
    const dispute = disputeResult.rows[0];
    
    // Update dispute
    await pool.query(`
      UPDATE disputes 
      SET status = 'resolved', 
          resolution = $1, 
          resolution_notes = $2,
          refund_amount_cents = $3,
          resolved_by = $4,
          resolved_at = NOW()
      WHERE id = $5
    `, [resolution, notes, refundAmount || 0, req.user.id, id]);
    
    // Update load status
    await pool.query(
      `UPDATE loads SET status = 'delivered', updated_at = NOW() WHERE id = $1`,
      [dispute.load_id]
    );
    
    // Process refund if needed
    if (refundAmount > 0 && ['full_refund', 'partial_refund'].includes(resolution)) {
      // TODO: Process Stripe refund
      console.log(`[Disputes] Would refund ${refundAmount} cents`);
    }
    
    // Notify both parties
    await emailService.sendDisputeResolved(
      dispute.filed_by_email,
      dispute.filed_by_name,
      dispute.load_id,
      resolution,
      notes
    );
    
    if (dispute.filed_against_email) {
      await emailService.sendDisputeResolved(
        dispute.filed_against_email,
        dispute.filed_against_name,
        dispute.load_id,
        resolution,
        notes
      );
    }
    
    res.json({ message: 'Dispute resolved', resolution });
  } catch (error) {
    console.error('[Disputes] Resolve error:', error);
    res.status(500).json({ error: 'Failed to resolve dispute' });
  }
});

module.exports = router;
