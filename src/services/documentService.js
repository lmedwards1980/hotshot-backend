// Generated by ScriptBuilder - 318 – S3 Document Service
// Feature: core | Role: core

// =========================================================
// 318 – S3 Document Service
// Feature: documents
// Role: storage
// Group: Backend API
// =========================================================
// FILE: src/services/documentService.js
// =========================================================

const { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand } = require('@aws-sdk/client-s3');
const { getSignedUrl } = require('@aws-sdk/s3-request-presigner');
const crypto = require('crypto');
const path = require('path');
const config = require('../config');



// === END REQUIRES ===

const s3Client = new S3Client({
  region: config.aws.region,
  credentials: {
    accessKeyId: config.aws.accessKeyId,
    secretAccessKey: config.aws.secretAccessKey,
  },
});

const BUCKET = config.aws.s3Bucket;

const DOCUMENT_TYPES = {
  cdl_front: { folder: 'cdl', required: true, label: 'CDL Front' },
  cdl_back: { folder: 'cdl', required: true, label: 'CDL Back' },
  insurance_certificate: { folder: 'insurance', required: true, label: 'Insurance Certificate' },
  mc_authority: { folder: 'mc_authority', required: false, label: 'MC Authority' },
  dot_certificate: { folder: 'dot_certificate', required: false, label: 'DOT Certificate' },
  profile_photo: { folder: 'profile_photos', required: false, label: 'Profile Photo' },
  load_photo: { folder: 'load_photos', required: false, label: 'Load Photo' },
  proof_of_delivery: { folder: 'pod', required: false, label: 'Proof of Delivery' },
};

const ALLOWED_MIME_TYPES = ['image/jpeg', 'image/png', 'application/pdf'];
const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB

const generateKey = (userId, docType, originalName) => {
  const ext = path.extname(originalName).toLowerCase();
  const hash = crypto.randomBytes(8).toString('hex');
  const timestamp = Date.now();
  const typeConfig = DOCUMENT_TYPES[docType];
  if (!typeConfig) throw new Error(`Invalid document type: ${docType}`);
  return `${typeConfig.folder}/${userId}/${timestamp}_${hash}${ext}`;
};

const getUploadUrl = async (userId, docType, contentType, fileName) => {
  if (!ALLOWED_MIME_TYPES.includes(contentType)) {
    throw new Error(`Invalid file type. Allowed: ${ALLOWED_MIME_TYPES.join(', ')}`);
  }
  const key = generateKey(userId, docType, fileName);
  const command = new PutObjectCommand({
    Bucket: BUCKET,
    Key: key,
    ContentType: contentType,
    Metadata: { 'user-id': userId, 'doc-type': docType, 'original-name': fileName },
  });
  const uploadUrl = await getSignedUrl(s3Client, command, { expiresIn: 300 });
  return { uploadUrl, key, expiresIn: 300 };
};

const getViewUrl = async (key, expiresIn = 3600) => {
  const command = new GetObjectCommand({ Bucket: BUCKET, Key: key });
  return getSignedUrl(s3Client, command, { expiresIn });
};

const uploadFile = async (userId, docType, fileBuffer, contentType, fileName) => {
  if (!ALLOWED_MIME_TYPES.includes(contentType)) throw new Error('Invalid file type');
  if (fileBuffer.length > MAX_FILE_SIZE) throw new Error('File too large');
  const key = generateKey(userId, docType, fileName);
  const command = new PutObjectCommand({
    Bucket: BUCKET, Key: key, Body: fileBuffer, ContentType: contentType,
    Metadata: { 'user-id': userId, 'doc-type': docType, 'original-name': fileName },
  });
  await s3Client.send(command);
  return { key, bucket: BUCKET };
};

const deleteFile = async (key) => {
  await s3Client.send(new DeleteObjectCommand({ Bucket: BUCKET, Key: key }));
  return true;
};

const getDriverDocumentStatus = async (pool, driverId) => {
  const result = await pool.query(
    `SELECT document_type, s3_key, status, uploaded_at, reviewed_at FROM driver_documents WHERE user_id = $1`,
    [driverId]
  );
  const uploaded = {};
  result.rows.forEach(doc => {
    uploaded[doc.document_type] = {
      key: doc.s3_key, status: doc.status, uploadedAt: doc.uploaded_at, verifiedAt: doc.reviewed_at,
    };
  });
  const status = {};
  Object.entries(DOCUMENT_TYPES).forEach(([type, config]) => {
    if (config.required || uploaded[type]) {
      status[type] = {
        label: config.label, required: config.required, uploaded: !!uploaded[type],
        status: uploaded[type]?.status || 'missing', ...uploaded[type],
      };
    }
  });
  const requiredCount = Object.values(DOCUMENT_TYPES).filter(d => d.required).length;
  const uploadedRequired = Object.entries(status).filter(([type, data]) => DOCUMENT_TYPES[type]?.required && data.uploaded).length;
  return { documents: status, complete: uploadedRequired >= requiredCount, progress: `${uploadedRequired}/${requiredCount}` };
};

module.exports = { DOCUMENT_TYPES, getUploadUrl, getViewUrl, uploadFile, deleteFile, getDriverDocumentStatus };
