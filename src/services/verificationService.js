// Generated by ScriptBuilder - 320 – Driver Verification Service
// Feature: core | Role: core

// =========================================================
// 320 – Driver Verification Service
// Feature: verification
// Role: background-check
// Group: Backend API
// =========================================================
// FILE: src/services/verificationService.js
// =========================================================

const axios = require('axios');
const config = require('../config');
const { pool } = require('../db/pool');
const emailService = require('./emailService');

// Checkr API for background checks
// https://docs.checkr.com/

const CHECKR_BASE_URL = config.checkr.sandbox 
  ? 'https://api.checkr-staging.com' 
  : 'https://api.checkr.com';

const checkrApi = axios.create({
  baseURL: CHECKR_BASE_URL,
  auth: {
    username: config.checkr.apiKey,
    password: '',
  },
  headers: {
    'Content-Type': 'application/json',
  },
});

// Verification status enum
const VERIFICATION_STATUS = {
  PENDING: 'pending',
  DOCUMENTS_REQUIRED: 'documents_required',
  DOCUMENTS_SUBMITTED: 'documents_submitted',
  BACKGROUND_CHECK_PENDING: 'background_check_pending',
  VERIFIED: 'verified',
  REJECTED: 'rejected',
  SUSPENDED: 'suspended',
};

// Create candidate in Checkr
const createCandidate = async (driverId, driverInfo) => {
  try {
    const response = await checkrApi.post('/v1/candidates', {
      first_name: driverInfo.firstName,
      last_name: driverInfo.lastName,
      email: driverInfo.email,
      phone: driverInfo.phone,
      dob: driverInfo.dateOfBirth, // YYYY-MM-DD
      ssn: driverInfo.ssn, // Last 4 or full
      driver_license_number: driverInfo.cdlNumber,
      driver_license_state: driverInfo.cdlState,
      custom_id: driverId,
    });
    
    // Store candidate ID
    await pool.query(
      `UPDATE driver_profiles 
       SET checkr_candidate_id = $1, updated_at = NOW()
       WHERE user_id = $2`,
      [response.data.id, driverId]
    );
    
    return { success: true, candidateId: response.data.id };
  } catch (error) {
    console.error('[Checkr] Create candidate failed:', error.response?.data || error.message);
    return { success: false, error: error.response?.data?.error || error.message };
  }
};

// Create background check invitation
const createInvitation = async (candidateId, packageSlug = 'driver_pro') => {
  try {
    // Available packages:
    // - driver_basic: MVR only
    // - driver_pro: MVR + criminal + SSN trace
    // - driver_plus: driver_pro + employment verification
    
    const response = await checkrApi.post('/v1/invitations', {
      candidate_id: candidateId,
      package: packageSlug,
    });
    
    return { 
      success: true, 
      invitationUrl: response.data.invitation_url,
      invitationId: response.data.id,
    };
  } catch (error) {
    console.error('[Checkr] Create invitation failed:', error.response?.data || error.message);
    return { success: false, error: error.response?.data?.error || error.message };
  }
};

// Get report status
const getReportStatus = async (reportId) => {
  try {
    const response = await checkrApi.get(`/v1/reports/${reportId}`);
    return {
      success: true,
      status: response.data.status,
      result: response.data.result,
      completedAt: response.data.completed_at,
      turnaroundTime: response.data.turnaround_time,
    };
  } catch (error) {
    return { success: false, error: error.message };
  }
};

// Webhook handler for Checkr events
const handleCheckrWebhook = async (event) => {
  const { type, data } = event;
  
  console.log(`[Checkr] Webhook: ${type}`, data.object?.id);
  
  switch (type) {
    case 'report.completed': {
      const reportId = data.object.id;
      const candidateId = data.object.candidate_id;
      const status = data.object.status;
      const result = data.object.result; // clear, consider, suspended
      
      // Find driver by candidate ID
      const driverResult = await pool.query(
        `SELECT dp.user_id, u.email, u.name
         FROM driver_profiles dp
         JOIN users u ON u.id = dp.user_id
         WHERE dp.checkr_candidate_id = $1`,
        [candidateId]
      );
      
      if (driverResult.rows.length === 0) {
        console.error('[Checkr] Unknown candidate:', candidateId);
        return;
      }
      
      const driver = driverResult.rows[0];
      let verificationStatus;
      
      if (result === 'clear') {
        verificationStatus = VERIFICATION_STATUS.VERIFIED;
        // Send verification email
        await emailService.sendDriverVerified(driver.email, driver.name);
      } else if (result === 'consider') {
        // Manual review needed
        verificationStatus = VERIFICATION_STATUS.PENDING;
        // Notify admin
      } else {
        verificationStatus = VERIFICATION_STATUS.REJECTED;
      }
      
      await pool.query(
        `UPDATE driver_profiles 
         SET verification_status = $1, 
             checkr_report_id = $2,
             verified_at = CASE WHEN $1 = 'verified' THEN NOW() ELSE NULL END,
             updated_at = NOW()
         WHERE user_id = $3`,
        [verificationStatus, reportId, driver.user_id]
      );
      
      break;
    }
    
    case 'candidate.created':
    case 'invitation.created':
    case 'invitation.completed':
      // Log for audit
      console.log(`[Checkr] ${type} processed`);
      break;
      
    default:
      console.log(`[Checkr] Unhandled event: ${type}`);
  }
};

// Manual verification (for admin)
const manualVerify = async (driverId, adminId, notes = '') => {
  await pool.query(
    `UPDATE driver_profiles 
     SET verification_status = $1, 
         verified_at = NOW(),
         verification_notes = $2,
         verified_by = $3,
         updated_at = NOW()
     WHERE user_id = $4`,
    [VERIFICATION_STATUS.VERIFIED, notes, adminId, driverId]
  );
  
  // Get driver info for email
  const result = await pool.query(
    `SELECT u.email, u.name FROM users u WHERE u.id = $1`,
    [driverId]
  );
  
  if (result.rows.length > 0) {
    await emailService.sendDriverVerified(result.rows[0].email, result.rows[0].name);
  }
  
  return { success: true };
};

// Manual rejection
const manualReject = async (driverId, adminId, reason) => {
  await pool.query(
    `UPDATE driver_profiles 
     SET verification_status = $1, 
         verification_notes = $2,
         verified_by = $3,
         updated_at = NOW()
     WHERE user_id = $4`,
    [VERIFICATION_STATUS.REJECTED, reason, adminId, driverId]
  );
  
  return { success: true };
};

// Get verification status for driver
const getVerificationStatus = async (driverId) => {
  // Check driver_profiles table with actual column names
  const result = await pool.query(
    `SELECT
       dp.license_number IS NOT NULL as has_license,
       dp.insurance_policy IS NOT NULL as has_insurance,
       u.is_verified
     FROM driver_profiles dp
     JOIN users u ON dp.user_id = u.id
     WHERE dp.user_id = $1`,
    [driverId]
  );

  if (result.rows.length === 0) {
    // Check if user exists but has no profile
    const userCheck = await pool.query(
      'SELECT is_verified FROM users WHERE id = $1',
      [driverId]
    );
    return {
      status: userCheck.rows.length > 0 ? 'pending' : 'no_profile',
      nextStep: 'create_profile',
      checklist: {
        documents: false,
        backgroundCheck: false,
        verified: false,
      },
    };
  }

  const profile = result.rows[0];
  const isVerified = profile.is_verified;

  // Determine next step
  let nextStep = null;
  if (!profile.has_license || !profile.has_insurance) {
    nextStep = 'upload_documents';
  } else if (!isVerified) {
    nextStep = 'wait_for_verification';
  }

  return {
    status: isVerified ? 'verified' : 'pending',
    verifiedAt: null,
    nextStep,
    checklist: {
      documents: profile.has_license && profile.has_insurance,
      backgroundCheck: true, // Simplified - assume background check not required for now
      verified: isVerified,
    },
  };
};

module.exports = {
  VERIFICATION_STATUS,
  createCandidate,
  createInvitation,
  getReportStatus,
  handleCheckrWebhook,
  manualVerify,
  manualReject,
  getVerificationStatus,
};
