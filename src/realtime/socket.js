// Generated by ScriptBuilder - 314 – WebSocket Handler
// Feature: realtime | Role: websocket

// =========================================================
// 015 – WebSocket Handler
// Feature: realtime
// Role: websocket
// Group: Realtime
// =========================================================
// FILE: src/realtime/socket.js
// =========================================================

const { Server } = require('socket.io');
const jwt = require('jsonwebtoken');
const config = require('../config');
const { pool } = require('../db/pool');
const { cacheDriverLocation } = require('../db/redis');

let io;

const initializeSocket = (server) => {
  io = new Server(server, {
    cors: {
      origin: '*', // Configure properly in production
      methods: ['GET', 'POST'],
    },
  });
  
  // Authentication middleware
  io.use(async (socket, next) => {
    try {
      const token = socket.handshake.auth.token;
      
      if (!token) {
        return next(new Error('Authentication required'));
      }
      
      const decoded = jwt.verify(token, config.jwt.secret);
      
      const result = await pool.query(
        'SELECT id, user_type, name FROM users WHERE id = $1 AND is_active = true',
        [decoded.userId]
      );
      
      if (result.rows.length === 0) {
        return next(new Error('User not found'));
      }
      
      socket.user = result.rows[0];
      next();
    } catch (error) {
      next(new Error('Invalid token'));
    }
  });
  
  io.on('connection', (socket) => {
    console.log(`[Socket] User connected: ${socket.user.id} (${socket.user.user_type})`);
    
    // Join user-specific room
    socket.join(`user:${socket.user.id}`);
    
    // Join role-specific room
    socket.join(`role:${socket.user.user_type}`);
    
    // Driver location updates
    if (socket.user.user_type === 'driver') {
      socket.on('location:update', async (data) => {
        try {
          const { latitude, longitude, heading, speedMph } = data;
          
          // Cache location
          await cacheDriverLocation(socket.user.id, latitude, longitude);
          
          // Update database
          await pool.query(
            `INSERT INTO driver_locations (driver_id, latitude, longitude, heading, speed_mph)
             VALUES ($1, $2, $3, $4, $5)
             ON CONFLICT (driver_id)
             DO UPDATE SET latitude = $2, longitude = $3, heading = $4, speed_mph = $5, updated_at = CURRENT_TIMESTAMP`,
            [socket.user.id, latitude, longitude, heading, speedMph]
          );
          
          // Broadcast to shipper if driver has active load
          const activeLoad = await pool.query(
            `SELECT shipper_id FROM loads
             WHERE driver_id = $1 AND status IN ('confirmed', 'en_route_pickup', 'picked_up', 'en_route_delivery')`,
            [socket.user.id]
          );
          
          if (activeLoad.rows.length > 0) {
            io.to(`user:${activeLoad.rows[0].shipper_id}`).emit('driver:location', {
              driverId: socket.user.id,
              latitude,
              longitude,
              heading,
              speedMph,
              updatedAt: new Date().toISOString(),
            });
          }
        } catch (error) {
          console.error('[Socket] Location update error:', error);
        }
      });
    }
    
    // Subscribe to load updates
    socket.on('load:subscribe', (loadId) => {
      socket.join(`load:${loadId}`);
      console.log(`[Socket] ${socket.user.id} subscribed to load ${loadId}`);
    });
    
    socket.on('load:unsubscribe', (loadId) => {
      socket.leave(`load:${loadId}`);
    });
    
    socket.on('disconnect', () => {
      console.log(`[Socket] User disconnected: ${socket.user.id}`);
    });
  });
  
  return io;
};

// Emit functions for use in routes/services
const emitToUser = (userId, event, data) => {
  if (io) {
    io.to(`user:${userId}`).emit(event, data);
  }
};

const emitToLoad = (loadId, event, data) => {
  if (io) {
    io.to(`load:${loadId}`).emit(event, data);
  }
};

const emitToDrivers = (event, data) => {
  if (io) {
    io.to('role:driver').emit(event, data);
  }
};

module.exports = {
  initializeSocket,
  emitToUser,
  emitToLoad,
  emitToDrivers,
};
